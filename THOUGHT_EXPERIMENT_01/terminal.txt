 î˜ª DELL  ~ î‚± ï„• î‚± LAB î‚± 01 [ î‚ master â‰¢ ï„ ~1 ]î‚° python .\overlapping_intervals.py

â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
EDUCATIONAL TEST: Interval Coverage Algorithm
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ


ğŸ§ª TEST CASE 1: Mixed overlapping intervals

======================================================================
ALGORITHM START: Remove Covered Intervals
======================================================================

ğŸ“¥ Input intervals: [(540, 660), (600, 720), (540, 720), (900, 960)]

----------------------------------------------------------------------
STEP 1: SORT INTERVALS
----------------------------------------------------------------------
Sort by: (start ascending, end descending)
Why? Longer intervals with same start come first

âœ“ Sorted result: [(540, 720), (540, 660), (600, 720), (900, 960)]

Visual timeline:
  1.  540- 720:                                                       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  2.  540- 660:                                                       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  3.  600- 720:                                                             â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  4.  900- 960:                                                                                           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

----------------------------------------------------------------------
STEP 2: RECURSIVE FILTERING
----------------------------------------------------------------------
Track max_end_so_far to detect covered intervals

ğŸ“ CALL: filter_covered([4 intervals], max_end=START)
   ğŸ” Examining: (540, 720)
   ğŸ¯ Current max_end_so_far: -inf
   âœ… NOT COVERED: 720 > -inf
      â†’ Keep this interval
      â†’ Update max_end: -inf â†’ 720
  ğŸ“ CALL: filter_covered([(540, 660), (600, 720), (900, 960)], max_end=720)
     ğŸ” Examining: (540, 660)
     ğŸ¯ Current max_end_so_far: 720
     âŒ COVERED: 660 â‰¤ 720
        â†’ Skip this interval
    ğŸ“ CALL: filter_covered([(600, 720), (900, 960)], max_end=720)
       ğŸ” Examining: (600, 720)
       ğŸ¯ Current max_end_so_far: 720
       âŒ COVERED: 720 â‰¤ 720
          â†’ Skip this interval
      ğŸ“ CALL: filter_covered([(900, 960)], max_end=720)
         ğŸ” Examining: (900, 960)
         ğŸ¯ Current max_end_so_far: 720
         âœ… NOT COVERED: 960 > 720
            â†’ Keep this interval
            â†’ Update max_end: 720 â†’ 960
        ğŸ“ CALL: filter_covered([], max_end=960)
           ğŸ›‘ BASE CASE: Empty list â†’ return []
         â¬…ï¸ RETURN: [(900, 960)]
       â¬…ï¸ RETURN: [(900, 960)]
     â¬…ï¸ RETURN: [(900, 960)]
   â¬…ï¸ RETURN: [(540, 720), (900, 960)]

======================================================================
ALGORITHM COMPLETE
======================================================================

ğŸ“¤ Input:  [(540, 660), (600, 720), (540, 720), (900, 960)]
ğŸ“¤ Output: [(540, 720), (900, 960)]

ğŸ“Š Removed 2 covered interval(s)
======================================================================


ğŸ’¡ KEY INSIGHTS:
   â€¢ (540, 720) covers both (540, 660) and (600, 720)
   â€¢ (900, 960) doesn't overlap with others â†’ kept
   â€¢ Only 2 intervals remain in final result


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

ğŸ§ª TEST CASE 2: No intervals are covered

======================================================================
ALGORITHM START: Remove Covered Intervals
======================================================================

ğŸ“¥ Input intervals: [(100, 200), (300, 400), (500, 600)]

----------------------------------------------------------------------
STEP 1: SORT INTERVALS
----------------------------------------------------------------------
Sort by: (start ascending, end descending)
Why? Longer intervals with same start come first

âœ“ Sorted result: [(100, 200), (300, 400), (500, 600)]

Visual timeline:
  1.  100- 200:           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  2.  300- 400:                               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  3.  500- 600:                                                   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

----------------------------------------------------------------------
STEP 2: RECURSIVE FILTERING
----------------------------------------------------------------------
Track max_end_so_far to detect covered intervals

ğŸ“ CALL: filter_covered([(100, 200), (300, 400), (500, 600)], max_end=START)
   ğŸ” Examining: (100, 200)
   ğŸ¯ Current max_end_so_far: -inf
   âœ… NOT COVERED: 200 > -inf
      â†’ Keep this interval
      â†’ Update max_end: -inf â†’ 200
  ğŸ“ CALL: filter_covered([(300, 400), (500, 600)], max_end=200)
     ğŸ” Examining: (300, 400)
     ğŸ¯ Current max_end_so_far: 200
     âœ… NOT COVERED: 400 > 200
        â†’ Keep this interval
        â†’ Update max_end: 200 â†’ 400
    ğŸ“ CALL: filter_covered([(500, 600)], max_end=400)
       ğŸ” Examining: (500, 600)
       ğŸ¯ Current max_end_so_far: 400
       âœ… NOT COVERED: 600 > 400
          â†’ Keep this interval
          â†’ Update max_end: 400 â†’ 600
      ğŸ“ CALL: filter_covered([], max_end=600)
         ğŸ›‘ BASE CASE: Empty list â†’ return []
       â¬…ï¸ RETURN: [(500, 600)]
     â¬…ï¸ RETURN: [(300, 400), (500, 600)]
   â¬…ï¸ RETURN: [3 intervals]

======================================================================
ALGORITHM COMPLETE
======================================================================

ğŸ“¤ Input:  [(100, 200), (300, 400), (500, 600)]
ğŸ“¤ Output: [(100, 200), (300, 400), (500, 600)]

ğŸ“Š Removed 0 covered interval(s)
======================================================================


ğŸ’¡ KEY INSIGHTS:
   â€¢ No intervals overlap at all
   â€¢ All intervals are kept


â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

ğŸ§ª TEST CASE 3: Fully nested intervals (Russian dolls)

======================================================================
ALGORITHM START: Remove Covered Intervals
======================================================================

ğŸ“¥ Input intervals: [(100, 1000), (200, 900), (300, 800), (400, 700)]

----------------------------------------------------------------------
STEP 1: SORT INTERVALS
----------------------------------------------------------------------
Sort by: (start ascending, end descending)
Why? Longer intervals with same start come first

âœ“ Sorted result: [(100, 1000), (200, 900), (300, 800), (400, 700)]

Visual timeline:
  1.  100-1000:           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  2.  200- 900:                     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  3.  300- 800:                               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  4.  400- 700:                                         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

----------------------------------------------------------------------
STEP 2: RECURSIVE FILTERING
----------------------------------------------------------------------
Track max_end_so_far to detect covered intervals

ğŸ“ CALL: filter_covered([4 intervals], max_end=START)
   ğŸ” Examining: (100, 1000)
   ğŸ¯ Current max_end_so_far: -inf
   âœ… NOT COVERED: 1000 > -inf
      â†’ Keep this interval
      â†’ Update max_end: -inf â†’ 1000
  ğŸ“ CALL: filter_covered([(200, 900), (300, 800), (400, 700)], max_end=1000)
     ğŸ” Examining: (200, 900)
     ğŸ¯ Current max_end_so_far: 1000
     âŒ COVERED: 900 â‰¤ 1000
        â†’ Skip this interval
    ğŸ“ CALL: filter_covered([(300, 800), (400, 700)], max_end=1000)
       ğŸ” Examining: (300, 800)
       ğŸ¯ Current max_end_so_far: 1000
       âŒ COVERED: 800 â‰¤ 1000
          â†’ Skip this interval
      ğŸ“ CALL: filter_covered([(400, 700)], max_end=1000)
         ğŸ” Examining: (400, 700)
         ğŸ¯ Current max_end_so_far: 1000
         âŒ COVERED: 700 â‰¤ 1000
            â†’ Skip this interval
        ğŸ“ CALL: filter_covered([], max_end=1000)
           ğŸ›‘ BASE CASE: Empty list â†’ return []
         â¬…ï¸ RETURN: []
       â¬…ï¸ RETURN: []
     â¬…ï¸ RETURN: []
   â¬…ï¸ RETURN: [(100, 1000)]

======================================================================
ALGORITHM COMPLETE
======================================================================

ğŸ“¤ Input:  [(100, 1000), (200, 900), (300, 800), (400, 700)]
ğŸ“¤ Output: [(100, 1000)]

ğŸ“Š Removed 3 covered interval(s)
======================================================================


ğŸ’¡ KEY INSIGHTS:
   â€¢ Largest interval (100, 1000) covers all others
   â€¢ All inner intervals are removed
   â€¢ Only the outermost interval remains
 î˜ª DELL  ~ î‚± ï„• î‚± LAB î‚± 01 [ î‚ master â‰¢ ï„ ~1 ]î‚°















