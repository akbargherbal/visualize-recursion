<codebase>
<project type='nodejs' language='javascript'>
<entry_points>
  <entry>frontend/src/index.js</entry>
  <entry>backend/app.py</entry>
</entry_points>
<dependencies>
  <dep>frontend/package.json</dep>
</dependencies>
</project>

<files>
<file path='README.md' size='5953' ext='.md'>
```
# Interval Coverage Visualization - Proof of Concept

## Project Overview

This POC demonstrates a clean separation between algorithmic computation (backend) and visualization (frontend).

**Philosophy:** Backend does ALL the thinking, frontend does ALL the reacting.

## Project Structure

```
interval-viz-poc/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ algorithms/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interval_coverage.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trace_generator.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TimelineView.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CallStackView.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Controls.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îî‚îÄ‚îÄ README.md
```

## Setup Instructions

### Backend Setup

```bash
# Navigate to backend
cd backend

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install flask flask-cors

# Create requirements.txt
pip freeze > requirements.txt

# Run backend
python app.py
```

Backend will run on `http://localhost:5000`

### Frontend Setup

```bash
# Navigate to frontend
cd frontend

# Initialize React app (if starting fresh)
npx create-react-app .

# Install dependencies
npm install lucide-react

# Install Tailwind CSS
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# Run frontend
npm start
```

Frontend will run on `http://localhost:3000`

## Key Files

### Backend: `algorithms/interval_coverage.py`

This file contains:
- `IntervalCoverageTracer` class that runs the algorithm
- Complete trace generation at EVERY step
- No frontend concerns - pure Python logic

**Key principle:** Generate complete "movie frames" that frontend can just display.

### Backend: `app.py`

Simple Flask API with two endpoints:
- `POST /api/trace` - Generate trace for given intervals
- `GET /api/examples` - Get pre-defined example inputs

### Frontend: `src/App.jsx`

React component that:
- Fetches trace from backend
- Displays current step
- Handles play/pause/step controls
- NO algorithmic logic

## Testing the POC

### 1. Start Backend
```bash
cd backend
python app.py
```

### 2. Test API Directly
```bash
curl -X POST http://localhost:5000/api/trace \
  -H "Content-Type: application/json" \
  -d '{
    "intervals": [
      {"id": 1, "start": 540, "end": 660, "color": "blue"},
      {"id": 2, "start": 600, "end": 720, "color": "green"}
    ]
  }'
```

You should see a complete JSON trace with all steps.

### 3. Start Frontend
```bash
cd frontend
npm start
```

Visit `http://localhost:3000` and you should see the visualization.

## What Makes This Different?

### ‚ùå Old Approach (Complex)
```javascript
// Frontend has algorithm logic
const processStep = () => {
  if (interval.end <= maxEnd) {
    // Make decisions
    // Update state
    // Compute values
  }
  // ... 200 lines of complexity
}
```

### ‚úÖ New Approach (Simple)
```javascript
// Frontend just displays
const step = trace.steps[currentStep];
return <TimelineView data={step.data} />
```

## Benefits

1. **Debugging:** Backend generates complete trace once. Frontend bugs are just UI bugs.

2. **Flexibility:** Change visualization without touching algorithm. Change algorithm without touching UI.

3. **Testing:** Backend can be unit tested independently. Frontend can use mock traces.

4. **Scalability:** Add new algorithms by creating new trace generators. Frontend components are reusable.

5. **Performance:** Complex computation happens once on backend. Frontend just plays the "movie".

## Next Steps for Production

1. **Add More Algorithms:**
   - Create new tracer classes (MergeSortTracer, DijkstraTracer, etc.)
   - Each outputs standardized trace format
   - Frontend components just work

2. **Enhance Visualization:**
   - Add more generic components (GraphView, ArrayView, TreeView)
   - Let backend specify which components to use via metadata

3. **User Input:**
   - Add form to let users input custom intervals
   - Backend validates and generates trace
   - Frontend displays result

4. **Save/Share:**
   - Store traces in database
   - Generate shareable links
   - Export as video/GIF

## Architecture Decision Record

**Decision:** Backend generates complete trace, frontend displays it.

**Rationale:**
- Separation of concerns
- Easier debugging (frontend bugs vs algorithm bugs)
- Reusable components
- Language strengths (Python for algorithms, React for UI)

**Trade-offs:**
- Larger initial payload (but cached/compressed easily)
- Backend must anticipate all visualization needs (but trace is flexible)

**Result:** Much simpler codebase, easier to maintain and extend.

## File Size Reference

- `interval_coverage.py`: ~200 lines (algorithm + trace generation)
- `app.py`: ~50 lines (simple API)
- `App.jsx`: ~150 lines (pure visualization)

Total: ~400 lines vs ~500+ lines with mixed concerns.

## Questions This POC Answers

1. ‚úÖ Can backend generate complete traces?
2. ‚úÖ Is the JSON payload reasonable size?
3. ‚úÖ Can frontend display traces without algorithmic logic?
4. ‚úÖ Is this approach scalable to other algorithms?
5. ‚úÖ Do the components feel reactive and responsive?

## Success Criteria

- [ ] Backend generates trace in <100ms
- [ ] JSON payload is <100KB uncompressed
- [ ] Frontend renders smoothly at 60fps
- [ ] Adding a new visualization component takes <1 hour
- [ ] Adding a new algorithm takes <2 hours
- [ ] Zero algorithm logic in React components
```
</file>

<file path='frontend/.gitignore' size='309' ext=''>
```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
```
</file>

<file path='frontend/README.md' size='865' ext='.md'>
```
# Frontend - Algorithm Visualization

Pure React visualization layer. **Zero algorithm logic** - just displays traces from backend.

## Setup

```bash
# Install dependencies
npm install

# Start development server
npm start
```

Runs on `http://localhost:3000`

## Architecture

- **App.jsx** - Main component, fetches trace from backend and controls playback
- **Components** - Reusable visualization components (Timeline, Details, etc.)

## Key Principle

Frontend does **ZERO computation**:
- No algorithm logic
- No state management of algorithm
- Just displays what backend sends

```javascript
// This is all the frontend does:
const step = trace.steps[currentStep];
return <TimelineView data={step} />;
```

## Backend Dependency

Frontend requires backend running on `http://localhost:5000`

If backend is down, frontend shows error with setup instructions.
```
</file>

<file path='frontend/package.json' size='786' ext='.json'>
```
{
  "name": "interval-viz-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "lucide-react": "^0.263.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "tailwindcss": "^3.3.0",
    "postcss": "^8.4.31",
    "autoprefixer": "^10.4.16"
  }
}
```
</file>

<file path='frontend/pnpm-lock.yaml' size='403565' excluded='token_limit'></file>
<file path='frontend/postcss.config.js' size='81' ext='.js'>
```
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```
</file>

<file path='frontend/tailwind.config.js' size='163' ext='.js'>
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```
</file>

<file path='frontend/src/App.jsx' size='22694' ext='.jsx'>
```
import React, { useState, useEffect, useRef } from "react";
import {
  SkipForward,
  SkipBack,
  Loader,
  AlertCircle,
  RotateCcw,
  Play,
  Pause,
  ChevronRight,
} from "lucide-react";

const AlgorithmTracePlayer = () => {
  const [trace, setTrace] = useState(null);
  const [currentStep, setCurrentStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const activeCallRef = useRef(null);

  const BACKEND_URL = "http://localhost:5000/api";

  useEffect(() => {
    loadExampleTrace();
  }, []);

  // Auto-play functionality
  useEffect(() => {
    if (!isPlaying || !trace) return;

    const timer = setInterval(() => {
      setCurrentStep((prev) => {
        if (prev >= trace.trace.steps.length - 1) {
          setIsPlaying(false);
          return prev;
        }
        return prev + 1;
      });
    }, 1200);

    return () => clearInterval(timer);
  }, [isPlaying, trace]);

  // Auto-scroll to active call
  useEffect(() => {
    if (activeCallRef.current) {
      activeCallRef.current.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  }, [currentStep]);

  const loadExampleTrace = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`${BACKEND_URL}/trace`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          intervals: [
            { id: 1, start: 540, end: 660, color: "blue" },
            { id: 2, start: 600, end: 720, color: "green" },
            { id: 3, start: 540, end: 720, color: "amber" },
            { id: 4, start: 900, end: 960, color: "purple" },
          ],
        }),
      });

      if (!response.ok) {
        throw new Error(`Backend returned ${response.status}`);
      }

      const data = await response.json();
      setTrace(data);
      setCurrentStep(0);
      setError(null);
    } catch (err) {
      setError(
        `Backend error: ${err.message}. Please start the Flask backend on port 5000.`
      );
      console.error("Failed to load trace:", err);
    }

    setLoading(false);
  };

  const nextStep = () => {
    if (trace && currentStep < trace.trace.steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const resetTrace = () => {
    setCurrentStep(0);
    setIsPlaying(false);
  };

  const togglePlay = () => {
    if (currentStep >= trace.trace.steps.length - 1) {
      setCurrentStep(0);
    }
    setIsPlaying(!isPlaying);
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-slate-900 flex items-center justify-center">
        <div className="text-center">
          <Loader
            className="animate-spin text-emerald-500 mx-auto mb-4"
            size={48}
          />
          <p className="text-white">Loading trace from backend...</p>
          <p className="text-gray-400 text-sm mt-2">
            Make sure Flask is running on port 5000
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-slate-900 flex items-center justify-center p-8">
        <div className="max-w-md text-center">
          <AlertCircle className="text-red-500 mx-auto mb-4" size={64} />
          <h2 className="text-xl font-bold text-white mb-4">
            Backend Not Available
          </h2>
          <p className="text-gray-300 mb-6">{error}</p>
          <div className="bg-slate-800 rounded-lg p-4 text-left mb-6">
            <p className="text-gray-400 text-sm mb-2">Start the backend:</p>
            <code className="text-emerald-400 text-xs">
              cd backend
              <br />
              python app.py
            </code>
          </div>
          <button
            onClick={loadExampleTrace}
            className="bg-emerald-500 hover:bg-emerald-400 text-black font-semibold px-6 py-2 rounded-lg transition"
          >
            Retry Connection
          </button>
        </div>
      </div>
    );
  }

  if (!trace) {
    return (
      <div className="min-h-screen bg-slate-900 flex items-center justify-center">
        <div className="text-center">
          <p className="text-white mb-4">No trace loaded</p>
          <button
            onClick={loadExampleTrace}
            className="bg-emerald-500 hover:bg-emerald-400 text-black font-semibold px-6 py-2 rounded-lg"
          >
            Load Example
          </button>
        </div>
      </div>
    );
  }

  const step = trace.trace.steps[currentStep];
  const isComplete = step.type === "ALGORITHM_COMPLETE";

  return (
    <div className="w-full h-screen bg-slate-900 flex items-center justify-center p-4 overflow-hidden">
      {/* Completion Modal */}
      {isComplete && (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="bg-slate-800 rounded-2xl shadow-2xl border-2 border-emerald-500 max-w-lg w-full p-8">
            <div className="text-center mb-6">
              <div className="inline-flex items-center justify-center w-16 h-16 bg-emerald-500 rounded-full mb-4">
                <svg
                  className="w-10 h-10 text-white"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={3}
                    d="M5 13l4 4L19 7"
                  />
                </svg>
              </div>
              <h2 className="text-3xl font-bold text-white mb-2">
                Algorithm Complete!
              </h2>
              <p className="text-slate-400">
                Successfully removed covered intervals
              </p>
            </div>

            <div className="bg-slate-900/50 rounded-lg p-6 mb-6">
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div className="text-center">
                  <div className="text-slate-400 text-sm mb-1">
                    Initial Intervals
                  </div>
                  <div className="text-3xl font-bold text-white">
                    {trace.metadata.input_size}
                  </div>
                </div>
                <div className="text-center">
                  <div className="text-slate-400 text-sm mb-1">
                    Kept Intervals
                  </div>
                  <div className="text-3xl font-bold text-emerald-400">
                    {step.data.kept_count}
                  </div>
                </div>
              </div>

              <div className="text-center pt-4 border-t border-slate-700">
                <div className="text-slate-400 text-sm mb-1">Removed</div>
                <div className="text-2xl font-bold text-red-400">
                  {step.data.removed_count} interval(s)
                </div>
              </div>
            </div>

            <div className="mb-6">
              <div className="text-slate-300 font-semibold mb-2">
                Final Result:
              </div>
              <div className="flex flex-wrap gap-2">
                {step.data.result.map((interval, idx) => {
                  const colorClass =
                    interval.color === "amber"
                      ? "bg-amber-500 text-black"
                      : interval.color === "blue"
                      ? "bg-blue-600 text-white"
                      : interval.color === "green"
                      ? "bg-green-600 text-white"
                      : "bg-purple-600 text-white";
                  return (
                    <div
                      key={idx}
                      className={`${colorClass} px-3 py-2 rounded-lg text-sm font-bold`}
                    >
                      ({interval.start}, {interval.end})
                    </div>
                  );
                })}
              </div>
            </div>

            <button
              onClick={resetTrace}
              className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg transition-colors flex items-center justify-center gap-2"
            >
              <RotateCcw size={20} />
              Start Over
            </button>
          </div>
        </div>
      )}

      <div className="w-full h-full max-w-7xl flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between mb-4">
          <div>
            <h1 className="text-2xl font-bold text-white">
              Remove Covered Intervals
            </h1>
            <p className="text-slate-400 text-sm">
              Step {currentStep + 1} of {trace.trace.steps.length}
            </p>
          </div>

          <div className="flex gap-2">
            <button
              onClick={resetTrace}
              className="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-colors"
            >
              <RotateCcw size={20} />
              Reset
            </button>

            <button
              onClick={togglePlay}
              disabled={isComplete}
              className="bg-blue-600 hover:bg-blue-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-colors"
            >
              {isPlaying ? (
                <>
                  <Pause size={20} />
                  Pause
                </>
              ) : (
                <>
                  <Play size={20} />
                  Play
                </>
              )}
            </button>

            <button
              onClick={prevStep}
              disabled={currentStep === 0}
              className="bg-slate-700 hover:bg-slate-600 disabled:bg-slate-800 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-colors"
            >
              <SkipBack size={20} />
              Previous
            </button>

            <button
              onClick={nextStep}
              disabled={currentStep === trace.trace.steps.length - 1}
              className="bg-emerald-500 hover:bg-emerald-600 disabled:bg-slate-600 disabled:cursor-not-allowed text-black px-6 py-2 rounded-lg flex items-center gap-2 transition-colors font-bold"
            >
              Next Step
              <ChevronRight size={20} />
            </button>
          </div>
        </div>

        {/* Main Content */}
        <div className="flex-1 flex gap-4 overflow-hidden">
          {/* Left: Timeline */}
          <div className="flex-1 bg-slate-800 rounded-xl p-6 shadow-2xl flex flex-col">
            <h2 className="text-white font-bold mb-4">
              Timeline Visualization
            </h2>
            <div className="flex-1 overflow-hidden">
              <TimelineView step={step} />
            </div>
          </div>

          {/* Right: Call Stack with STICKY controls at bottom */}
          <div className="w-96 bg-slate-800 rounded-xl shadow-2xl flex flex-col">
            {/* Stack header */}
            <div className="p-6 pb-4 border-b border-slate-700">
              <h2 className="text-white font-bold flex items-center gap-2">
                Recursive Call Stack
                {step.data.call_stack_state &&
                  step.data.call_stack_state.length > 0 && (
                    <span className="text-xs bg-emerald-500 text-white px-2 py-1 rounded-full">
                      {step.data.call_stack_state.length} calls
                    </span>
                  )}
              </h2>
            </div>

            {/* Scrollable call stack */}
            <div className="flex-1 overflow-y-auto p-6">
              <CallStackView step={step} activeCallRef={activeCallRef} />
            </div>

            {/* STICKY Controls at bottom */}
            <div className="border-t border-slate-700 p-4 bg-slate-800">
              <div className="mb-3 p-3 bg-slate-700/50 rounded-lg">
                <p className="text-white text-sm font-medium mb-1">
                  {step.description}
                </p>
                <p className="text-slate-400 text-xs">
                  {step.type.replace(/_/g, " ")}
                </p>
              </div>

              <div className="flex gap-2">
                <button
                  onClick={prevStep}
                  disabled={currentStep === 0}
                  className="flex-1 bg-slate-700 hover:bg-slate-600 disabled:bg-slate-900 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors"
                >
                  <SkipBack size={18} />
                  Previous
                </button>

                <button
                  onClick={nextStep}
                  disabled={currentStep === trace.trace.steps.length - 1}
                  className="flex-1 bg-emerald-500 hover:bg-emerald-600 disabled:bg-slate-700 disabled:cursor-not-allowed text-black px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors font-bold"
                >
                  Next Step
                  <ChevronRight size={18} />
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

const TimelineView = ({ step }) => {
  const allIntervals = step.data.all_intervals || [];
  const maxEnd = step.data.max_end;

  const minVal = 500;
  const maxVal = 1000;
  const toPercent = (val) => ((val - minVal) / (maxVal - minVal)) * 100;

  const colorMap = {
    blue: { bg: "bg-blue-800", text: "text-white", border: "border-blue-600" },
    green: {
      bg: "bg-green-600",
      text: "text-white",
      border: "border-green-500",
    },
    amber: {
      bg: "bg-amber-500",
      text: "text-black",
      border: "border-amber-400",
    },
    purple: {
      bg: "bg-purple-600",
      text: "text-white",
      border: "border-purple-500",
    },
  };

  return (
    <div className="relative h-full flex flex-col">
      <div className="relative flex-1 bg-slate-900/50 rounded-lg p-4">
        {/* Timeline axis */}
        <div className="absolute bottom-6 left-4 right-4 h-0.5 bg-slate-600"></div>

        {/* Scale markers */}
        <div className="absolute bottom-1 left-4 text-slate-400 text-xs">
          {minVal}
        </div>
        <div className="absolute bottom-1 left-1/3 text-slate-400 text-xs">
          700
        </div>
        <div className="absolute bottom-1 left-2/3 text-slate-400 text-xs">
          850
        </div>
        <div className="absolute bottom-1 right-4 text-slate-400 text-xs">
          {maxVal}
        </div>

        {/* Max end line */}
        {maxEnd !== undefined && maxEnd !== null && (
          <div
            className="absolute top-4 bottom-6 w-0.5 bg-cyan-400 z-10"
            style={{ left: `${4 + toPercent(maxEnd) * 0.92}%` }}
          >
            <div className="absolute -top-6 -left-12 bg-cyan-400 text-slate-900 text-xs px-2 py-1 rounded font-bold whitespace-nowrap">
              max_end: {maxEnd}
            </div>
          </div>
        )}

        {/* Interval bars */}
        {allIntervals.map((interval, idx) => {
          const left = toPercent(interval.start);
          const width = toPercent(interval.end) - toPercent(interval.start);
          const colors = colorMap[interval.color] || {
            bg: "bg-gray-500",
            text: "text-white",
            border: "border-gray-400",
          };

          const visualState = interval.visual_state || {};
          const isExamining = visualState.is_examining;
          const isCovered = visualState.is_covered;
          const isKept = visualState.is_kept;

          let additionalClasses = "transition-all duration-300";

          if (isExamining) {
            additionalClasses += " ring-4 ring-yellow-400 scale-105";
          }

          if (isCovered) {
            additionalClasses += " opacity-30 line-through";
          }

          if (isKept) {
            additionalClasses += " shadow-lg shadow-emerald-500/50";
          }

          return (
            <div
              key={interval.id}
              className={`absolute h-10 ${colors.bg} rounded border-2 ${colors.border} flex items-center justify-center text-white text-sm font-bold ${additionalClasses}`}
              style={{
                left: `${4 + left * 0.92}%`,
                width: `${width * 0.92}%`,
                top: `${4 + idx * 48}px`,
              }}
            >
              {interval.start}-{interval.end}
            </div>
          );
        })}
      </div>

      {/* Legend */}
      <div className="mt-4 flex gap-4 text-xs">
        <div className="flex items-center gap-2">
          <div className="w-8 h-3 bg-cyan-400 rounded"></div>
          <span className="text-slate-400">max_end line</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-8 h-3 bg-yellow-400 rounded ring-2 ring-yellow-400"></div>
          <span className="text-slate-400">examining</span>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-8 h-3 bg-slate-500 opacity-30 rounded line-through"></div>
          <span className="text-slate-400">covered (skipped)</span>
        </div>
      </div>
    </div>
  );
};

const CallStackView = ({ step, activeCallRef }) => {
  const callStack = step.data.call_stack_state || [];

  if (callStack.length === 0) {
    return (
      <div className="text-slate-500 text-sm italic">
        {step.type === "INITIAL_STATE" && "Sort intervals first to begin"}
        {step.type === "SORT_BEGIN" && "Sorting intervals..."}
        {step.type === "SORT_COMPLETE" && "Ready to start recursion"}
      </div>
    );
  }

  return (
    <div className="space-y-2">
      {callStack.map((call, idx) => {
        const isActive = idx === callStack.length - 1;
        const currentInterval = call.current_interval;

        if (!currentInterval) return null;

        return (
          <div
            key={call.call_id}
            ref={isActive ? activeCallRef : null}
            className={`p-3 rounded-lg border-2 transition-all ${
              isActive
                ? "border-yellow-400 bg-yellow-900/20 shadow-lg"
                : call.status === "returning"
                ? "border-emerald-400 bg-emerald-900/20"
                : "border-slate-600 bg-slate-800/50"
            }`}
            style={{ marginLeft: `${call.depth * 24}px` }}
          >
            {/* Call header */}
            <div className="flex items-center gap-2 mb-2">
              <div className="text-slate-400 text-xs font-mono">
                CALL #{call.call_id}
              </div>
              <ChevronRight size={12} className="text-slate-500" />
              <div className="text-white text-xs font-mono">
                depth={call.depth}, remaining={call.remaining_count}
              </div>
            </div>

            {/* Current interval */}
            <div className="flex items-center gap-2 mb-2">
              <div className="text-slate-400 text-xs">Examining:</div>
              <div
                className={`px-2 py-1 rounded text-xs font-bold ${
                  currentInterval.color === "amber"
                    ? "bg-amber-500 text-black"
                    : currentInterval.color === "blue"
                    ? "bg-blue-600 text-white"
                    : currentInterval.color === "green"
                    ? "bg-green-600 text-white"
                    : "bg-purple-600 text-white"
                }`}
              >
                ({currentInterval.start}, {currentInterval.end})
              </div>
            </div>

            {/* Max end */}
            <div className="flex items-center gap-2 mb-2">
              <div className="text-slate-400 text-xs">max_end_so_far:</div>
              <div className="text-cyan-400 text-xs font-mono font-bold">
                {call.max_end === null || call.max_end === undefined
                  ? "-‚àû"
                  : call.max_end}
              </div>
            </div>

            {/* Decision */}
            {call.decision && (
              <div
                className={`flex items-center gap-2 p-2 rounded ${
                  call.decision === "keep"
                    ? "bg-emerald-900/30 border border-emerald-500"
                    : "bg-red-900/30 border border-red-500"
                }`}
              >
                <div className="text-xs font-bold">
                  {call.decision === "keep" ? "‚úÖ KEEP" : "‚ùå COVERED"}
                </div>
                <div className="text-xs text-slate-300">
                  {currentInterval.end} {call.decision === "keep" ? ">" : "‚â§"}{" "}
                  {call.max_end === null ? "-‚àû" : call.max_end}
                </div>
              </div>
            )}

            {/* Return value */}
            {call.return_value && call.return_value.length > 0 && (
              <div className="mt-2 pt-2 border-t border-slate-600">
                <div className="text-slate-400 text-xs mb-1">‚Ü©Ô∏è RETURN:</div>
                <div className="flex flex-wrap gap-1">
                  {call.return_value.length === 0 ? (
                    <div className="text-slate-500 text-xs italic">[]</div>
                  ) : (
                    call.return_value.map((interval, idx) => {
                      const colorClass =
                        interval.color === "amber"
                          ? "bg-amber-500 text-black"
                          : interval.color === "blue"
                          ? "bg-blue-600 text-white"
                          : interval.color === "green"
                          ? "bg-green-600 text-white"
                          : "bg-purple-600 text-white";
                      return (
                        <div
                          key={idx}
                          className={`${colorClass} px-2 py-1 rounded text-xs`}
                        >
                          ({interval.start},{interval.end})
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
            )}
          </div>
        );
      })}
    </div>
  );
};

export default AlgorithmTracePlayer;
```
</file>

<file path='frontend/src/index.css' size='501' ext='.css'>
```
@tailwind base;
@tailwind components;
@tailwind utilities;

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #0f172a;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
```
</file>

<file path='frontend/src/index.js' size='253' ext='.js' imports='react,react-dom/client,./App'>
```
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```
</file>

<file path='frontend/public/index.html' size='502' ext='.html'>
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Algorithm visualization with complete backend-generated traces"
    />
    <title>Interval Coverage Visualization</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```
</file>

<file path='backend/app.py' size='3131' ext='.py' imports='flask,flask_cors,algorithms.interval_coverage'>
```
# backend/app.py
from flask import Flask, jsonify, request
from flask_cors import CORS
from algorithms.interval_coverage import Interval, IntervalCoverageTracer

app = Flask(__name__)
CORS(app)  # Allow frontend to call backend


@app.route('/api/trace', methods=['POST'])
def generate_trace():
    """
    Accept intervals, return complete trace.
    Frontend sends: {"intervals": [...]}
    Backend returns: {"result": [...], "trace": {...}, "metadata": {...}}
    """
    try:
        data = request.json
        
        if not data or 'intervals' not in data:
            return jsonify({"error": "Missing 'intervals' in request body"}), 400
        
        # Convert input to Interval objects
        intervals = [
            Interval(
                id=i['id'],
                start=i['start'],
                end=i['end'],
                color=i.get('color', 'blue')
            )
            for i in data['intervals']
        ]
        
        # Generate trace
        tracer = IntervalCoverageTracer()
        result = tracer.remove_covered_intervals(intervals)
        
        return jsonify(result)
    
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/examples', methods=['GET'])
def get_examples():
    """Provide pre-defined example inputs (NOT traces - just inputs!)"""
    examples = [
        {
            "name": "Basic Example",
            "intervals": [
                {"id": 1, "start": 540, "end": 660, "color": "blue"},
                {"id": 2, "start": 600, "end": 720, "color": "green"},
                {"id": 3, "start": 540, "end": 720, "color": "amber"},
                {"id": 4, "start": 900, "end": 960, "color": "purple"}
            ]
        },
        {
            "name": "All Disjoint",
            "intervals": [
                {"id": 1, "start": 100, "end": 200, "color": "blue"},
                {"id": 2, "start": 300, "end": 400, "color": "green"},
                {"id": 3, "start": 500, "end": 600, "color": "amber"}
            ]
        },
        {
            "name": "All Covered",
            "intervals": [
                {"id": 1, "start": 100, "end": 500, "color": "amber"},
                {"id": 2, "start": 150, "end": 200, "color": "blue"},
                {"id": 3, "start": 250, "end": 350, "color": "green"}
            ]
        }
    ]
    return jsonify(examples)


@app.route('/api/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "algorithm-trace-backend",
        "available_algorithms": ["interval-coverage"]
    })


if __name__ == '__main__':
    print("=" * 60)
    print("üöÄ Algorithm Trace Backend Starting...")
    print("=" * 60)
    print("üìç Running on: http://localhost:5000")
    print("üìä Available endpoints:")
    print("   POST /api/trace      - Generate algorithm trace")
    print("   GET  /api/examples   - Get example inputs")
    print("   GET  /api/health     - Health check")
    print("=" * 60)
    print()
    
    # For development
    app.run(debug=True, port=5000)
```
</file>

<file path='backend/algorithms/__init__.py' size='323' ext='.py'>
```
# backend/algorithms/__init__.py
"""
Algorithm tracer modules.

Each algorithm module exports:
- Data classes for the algorithm's input
- A Tracer class that generates complete execution traces
"""

from .interval_coverage import Interval, IntervalCoverageTracer

__all__ = [
    'Interval',
    'IntervalCoverageTracer',
]
```
</file>

<file path='backend/algorithms/interval_coverage.py' size='13496' ext='.py' imports='time,typing,dataclasses'>
```
# backend/algorithms/interval_coverage.py
"""
Remove Covered Intervals Algorithm with Complete Trace Generation.

This module generates a complete execution trace of the interval coverage
algorithm, allowing the frontend to visualize every step without any
algorithmic logic on its side.
"""

from typing import List
from dataclasses import dataclass, asdict
import time


@dataclass
class Interval:
    """Represents a time interval with visual properties."""
    id: int
    start: int
    end: int
    color: str


@dataclass
class TraceStep:
    """A single step in the algorithm execution trace."""
    step: int
    type: str
    timestamp: float
    data: dict
    description: str


class IntervalCoverageTracer:
    """
    Remove covered intervals algorithm with complete trace generation.
    
    Philosophy: Backend does ALL computation, frontend just displays.
    Every decision, comparison, and state change is recorded.
    """
    
    def __init__(self):
        self.trace = []
        self.step_count = 0
        self.start_time = time.time()
        self.call_stack = []
        self.next_call_id = 0
        self.original_intervals = []  # Keep reference to ALL intervals
        self.interval_states = {}  # Track visual state of each interval
        
    def _add_step(self, step_type: str, data: dict, description: str):
        """Record a step in the algorithm execution with complete visual state."""
        # Enrich data with full visual state for ALL intervals
        enriched_data = {
            **data,
            'all_intervals': self._get_all_intervals_with_state(),
            'call_stack_state': self._get_call_stack_state()
        }
        
        self.trace.append(TraceStep(
            step=self.step_count,
            type=step_type,
            timestamp=time.time() - self.start_time,
            data=enriched_data,
            description=description
        ))
        self.step_count += 1
    
    def _serialize_value(self, value):
        """Convert Python values to JSON-safe values."""
        if value == float('-inf'):
            return None
        if value == float('inf'):
            return None
        return value
    
    def _get_all_intervals_with_state(self):
        """Get all original intervals with their current visual state."""
        return [
            {
                **asdict(interval),
                'visual_state': self.interval_states.get(interval.id, {
                    'is_examining': False,
                    'is_covered': False,
                    'is_kept': False,
                    'in_current_subset': True
                })
            }
            for interval in self.original_intervals
        ]
    
    def _get_call_stack_state(self):
        """Get complete call stack state for visualization."""
        return [
            {
                'call_id': call['id'],
                'depth': call['depth'],
                'current_interval': asdict(call['current']) if call.get('current') else None,
                'max_end': self._serialize_value(call['max_end']),
                'remaining_count': len(call['remaining']),
                'status': call['status'],
                'decision': call.get('decision'),
                'return_value': [asdict(i) for i in call.get('return_value', [])]
            }
            for call in self.call_stack
        ]
    
    def _reset_all_visual_states(self):
        """Reset all interval visual states."""
        for interval_id in self.interval_states:
            self.interval_states[interval_id] = {
                'is_examining': False,
                'is_covered': False,
                'is_kept': False,
                'in_current_subset': True
            }
    
    def _set_visual_state(self, interval_id, **kwargs):
        """Update visual state for a specific interval."""
        if interval_id not in self.interval_states:
            self.interval_states[interval_id] = {
                'is_examining': False,
                'is_covered': False,
                'is_kept': False,
                'in_current_subset': True
            }
        self.interval_states[interval_id].update(kwargs)
    
    def remove_covered_intervals(self, intervals: List[Interval]) -> dict:
        """
        Main algorithm with complete trace generation.
        
        Args:
            intervals: List of Interval objects to process
            
        Returns:
            dict containing:
                - result: List of kept intervals
                - trace: Complete execution trace with all steps
                - metadata: Algorithm metadata
        """
        # Store original intervals
        self.original_intervals = intervals
        
        # Initialize visual states
        for interval in intervals:
            self.interval_states[interval.id] = {
                'is_examining': False,
                'is_covered': False,
                'is_kept': False,
                'in_current_subset': True
            }
        
        # Step 0: Initial state
        self._add_step(
            "INITIAL_STATE",
            {
                "intervals": [asdict(i) for i in intervals],
                "count": len(intervals)
            },
            "Original unsorted intervals"
        )
        
        # Step 1: Sort
        self._add_step(
            "SORT_BEGIN",
            {"description": "Sorting by (start ‚Üë, end ‚Üì)"},
            "Preparing to sort intervals"
        )
        
        sorted_intervals = sorted(intervals, key=lambda x: (x.start, -x.end))
        
        self._add_step(
            "SORT_COMPLETE",
            {"intervals": [asdict(i) for i in sorted_intervals]},
            "Intervals sorted - ready for recursion"
        )
        
        # Step 2: Recursive filtering
        result = self._filter_recursive(sorted_intervals, float('-inf'))
        
        # Mark all kept intervals
        for interval in result:
            self._set_visual_state(interval.id, is_kept=True)
        
        # Final step
        self._add_step(
            "ALGORITHM_COMPLETE",
            {
                "result": [asdict(i) for i in result],
                "kept_count": len(result),
                "removed_count": len(intervals) - len(result)
            },
            f"Algorithm complete: kept {len(result)}/{len(intervals)} intervals"
        )
        
        return {
            "result": [asdict(i) for i in result],
            "trace": {
                "steps": [asdict(s) for s in self.trace],
                "total_steps": len(self.trace),
                "duration": time.time() - self.start_time
            },
            "metadata": {
                "algorithm": "remove-covered-intervals",
                "input_size": len(intervals),
                "output_size": len(result)
            }
        }
    
    def _filter_recursive(self, intervals: List[Interval], max_end: float) -> List[Interval]:
        """
        Recursive filtering with complete trace generation.
        
        Every recursive call, comparison, and decision is traced.
        """
        # Base case
        if not intervals:
            call_id = self.next_call_id
            self.next_call_id += 1
            
            self._add_step(
                "BASE_CASE",
                {
                    "call_id": call_id,
                    "max_end": self._serialize_value(max_end),
                    "description": "No intervals remaining - return empty list"
                },
                "Base case reached"
            )
            return []
        
        # Start new recursive call
        call_id = self.next_call_id
        self.next_call_id += 1
        depth = len(self.call_stack)
        
        current = intervals[0]
        remaining = intervals[1:]
        
        # Add to call stack
        call_info = {
            'id': call_id,
            'depth': depth,
            'current': current,
            'remaining': remaining,
            'max_end': max_end,
            'status': 'examining',
            'decision': None,
            'return_value': []
        }
        self.call_stack.append(call_info)
        
        # Mark current interval as examining
        self._reset_all_visual_states()
        self._set_visual_state(current.id, is_examining=True, in_current_subset=True)
        
        # Mark remaining intervals as in current subset
        for interval in remaining:
            self._set_visual_state(interval.id, in_current_subset=True)
        
        # Trace: Call start
        self._add_step(
            "CALL_START",
            {
                "call_id": call_id,
                "depth": depth,
                "examining": asdict(current),
                "max_end": self._serialize_value(max_end),
                "remaining_count": len(remaining),
                "intervals": [asdict(i) for i in intervals]
            },
            f"Call #{call_id}: examining interval ({current.start}, {current.end})"
        )
        
        # Trace: Examining interval
        self._add_step(
            "EXAMINING_INTERVAL",
            {
                "call_id": call_id,
                "interval": asdict(current),
                "max_end": self._serialize_value(max_end),
                "comparison": f"{current.end} vs {max_end if max_end != float('-inf') else 'None'}"
            },
            f"Comparing interval end ({current.end}) with max_end"
        )
        
        # Make decision: Keep or covered?
        is_covered = current.end <= max_end
        decision = "covered" if is_covered else "keep"
        
        # Update call info
        call_info['status'] = 'decided'
        call_info['decision'] = decision
        
        # Update visual state based on decision
        if is_covered:
            self._set_visual_state(current.id, is_covered=True, is_examining=False)
        else:
            self._set_visual_state(current.id, is_examining=False)
        
        # Trace: Decision made
        self._add_step(
            "DECISION_MADE",
            {
                "call_id": call_id,
                "interval": asdict(current),
                "decision": decision,
                "reason": f"end={current.end} {'<=' if is_covered else '>'} max_end={max_end if max_end != float('-inf') else 'None'}",
                "will_keep": not is_covered
            },
            f"Decision: {decision.upper()}"
        )
        
        if not is_covered:
            # Keep this interval - update max_end
            new_max_end = max(max_end, current.end)
            
            self._add_step(
                "MAX_END_UPDATE",
                {
                    "call_id": call_id,
                    "interval": asdict(current),
                    "old_max_end": self._serialize_value(max_end),
                    "new_max_end": new_max_end
                },
                f"Updating max_end: {max_end if max_end != float('-inf') else '-‚àû'} ‚Üí {new_max_end}"
            )
            
            # Recurse with updated max_end
            rest = self._filter_recursive(remaining, new_max_end)
            result = [current] + rest
        else:
            # Skip this interval (it's covered)
            result = self._filter_recursive(remaining, max_end)
        
        # Update return value in call info
        call_info['status'] = 'returning'
        call_info['return_value'] = result
        
        # Trace: Return from call
        self._add_step(
            "CALL_RETURN",
            {
                "call_id": call_id,
                "depth": depth,
                "return_value": [asdict(i) for i in result],
                "kept_count": len(result)
            },
            f"Call #{call_id} returning {len(result)} interval(s)"
        )
        
        self.call_stack.pop()
        return result


# Standalone test/demo
if __name__ == "__main__":
    print("=" * 60)
    print("Testing Interval Coverage Tracer")
    print("=" * 60)
    
    # Test the tracer
    test_intervals = [
        Interval(1, 540, 660, "blue"),
        Interval(2, 600, 720, "green"),
        Interval(3, 540, 720, "amber"),
        Interval(4, 900, 960, "purple")
    ]
    
    print(f"\nInput: {len(test_intervals)} intervals")
    for interval in test_intervals:
        print(f"  [{interval.start}, {interval.end}] (id={interval.id})")
    
    tracer = IntervalCoverageTracer()
    result = tracer.remove_covered_intervals(test_intervals)
    
    print(f"\n‚úì Result: {len(result['result'])} intervals kept")
    print(f"‚úì Trace: {result['trace']['total_steps']} steps recorded")
    print(f"‚úì Duration: {result['trace']['duration']:.4f}s")
    
    print("\nFirst 5 steps:")
    for step in result['trace']['steps'][:5]:
        print(f"  {step['step']}: {step['type']} - {step['description']}")
    
    print("\nSample step with visual state (step 5):")
    step_5 = result['trace']['steps'][5]
    print(f"  Type: {step_5['type']}")
    print(f"  All intervals with visual state:")
    for interval in step_5['data']['all_intervals'][:2]:  # Show first 2
        print(f"    ID {interval['id']}: examining={interval['visual_state']['is_examining']}, covered={interval['visual_state']['is_covered']}")
    
    print("\nKept intervals:")
    for interval in result['result']:
        print(f"  [{interval['start']}, {interval['end']}] (id={interval['id']})")
    
    print("\n" + "=" * 60)
```
</file>


<!-- Ignored directories summary -->
<!-- Ignored: frontend/node_modules -->
<!-- Ignored: backend/algorithms/__pycache__ -->
<!-- Total ignored files: ~10,002 -->
</files>
</codebase>
